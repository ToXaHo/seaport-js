import {BigNumberish} from "ethers";
import {
    Asset,
    Token,
    OfferType,
    ExchangeMetadata,
    APIConfig
} from "web3-accounts"
import {BigNumber} from 'web3-wallets'
import {ItemType, OrderType} from "./constants";

export {OrderType}
export {
    NULL_BLOCK_HASH,
    NULL_ADDRESS, getProvider, getEstimateGas,
    ethSend,
    BigNumber,
    ETH_TOKEN_ADDRESS,
    CHAIN_CONFIG,
    getChainRpcUrl,
    hexUtils,
    getEIP712DomainHash,
    createEIP712TypedData
} from 'web3-wallets'
export type {Signature, WalletInfo, LimitedCallSpec, EIP712TypedData, EIP712Domain} from 'web3-wallets'

export type {Asset, Token, APIConfig, ExchangeMetadata}

export type InputCriteria = {
    identifier: string;
    proof: string[];
};

export type NftItemType =
    | ItemType.ERC721
    | ItemType.ERC1155
    | ItemType.ERC721_WITH_CRITERIA
    | ItemType.ERC1155_WITH_CRITERIA;

export enum BasicOrderRouteType {
    ETH_TO_ERC721,
    ETH_TO_ERC1155,
    ERC20_TO_ERC721,
    ERC20_TO_ERC1155,
    ERC721_TO_ERC20,
    ERC1155_TO_ERC20,
}

export type OfferItem = {
    itemType: ItemType;
    token: string;
    identifierOrCriteria: string;
    startAmount: string;
    endAmount: string;
};

export type ConsiderationItem = {
    itemType: ItemType;
    token: string;
    identifierOrCriteria: string;
    startAmount: string;
    endAmount: string;
    recipient: string;
};

export type Item = OfferItem | ConsiderationItem;

export type OrderParameters = {
    offerer: string;
    zone: string;
    orderType: OrderType;
    startTime: BigNumberish;
    endTime: BigNumberish;
    zoneHash: string;
    salt: string;
    offer: OfferItem[];
    consideration: ConsiderationItem[];
    totalOriginalConsiderationItems: BigNumberish;
    conduitKey: string;
};

export type OrderComponents = OrderParameters & { counter: number };

export type Order = {
    parameters: OrderParameters;
    signature: string;
};

export type OrderStatus = {
    isValidated: boolean;
    isCancelled: boolean;
    totalFilled: BigNumber;
    totalSize: BigNumber;
};

export type OrderWithCounter = {
    parameters: OrderComponents;
    signature: string;
};

//----------- Item-------------
export type BasicErc721Item = {
    itemType: ItemType.ERC721;
    token: string;
    identifier: string;
};

export type Erc721ItemWithCriteria = {
    itemType: ItemType.ERC721;
    token: string;
    identifiers: string[];
    // Used for criteria based items i.e. offering to buy 5 NFTs for a collection
    amount?: string;
    endAmount?: string;
};

type Erc721Item = BasicErc721Item | Erc721ItemWithCriteria;

export type BasicErc1155Item = {
    itemType: ItemType.ERC1155;
    token: string;
    identifier: string;
    amount: string;
    endAmount?: string;
};

export type Erc1155ItemWithCriteria = {
    itemType: ItemType.ERC1155;
    token: string;
    identifiers: string[];
    amount: string;
    endAmount?: string;
};

type Erc1155Item = BasicErc1155Item | Erc1155ItemWithCriteria;

export type CurrencyItem = {
    token?: string;
    amount: string;
    endAmount?: string;
};
export type CreateInputItem = Erc721Item | Erc1155Item | CurrencyItem;
export type TipInputItem = CreateInputItem & { recipient: string };
//--------- old ---------------------

export interface OrdersQueryParams {
    token_ids: string[]
    asset_contract_address: string
    payment_token_address?: string
    include_bundled?: boolean
    maker?: string
    taker?: string
    side?: number
    owner?: string
    order_by?: string
    limit?: number
    offset?: number
}

export interface AssetsQueryParams {
    assets?: {
        asset_contract_addresses: string
        token_ids?: string
    }[],
    owner?: string
    limit?: number
    include_orders?: boolean
}

export interface FeesInfo {
    royaltyFeeAddress: string
    royaltyFeePoint: number
    protocolFeePoint?: number
    protocolFeeAddress?: string
}

export interface AssetCollection extends FeesInfo {
    name: string
    symbol: string
    address?: string
    token_id?: string
    schema_name?: string
    nft_version?: string
    created_date?: string
    sell_orders?: any
}

export interface ElementRoyaltyInfo {
    transferFeeAddress: string
    elementSellerFeeBasisPoints: number
}


// export interface OpenSeaUser {
//     // Username for this user
//     username: string
// }
//
// export interface OpenSeaAccount {
//     // Wallet address for this account
//     address: string
//     // Public configuration info, including "affiliate" for users who are in the Element affiliate program
//     config: string
//
//     // This account's profile image - by default, randomly generated by the server
//     profileImgUrl: string
//
//     // More information explicitly set by this account's owner on Element
//     user: OpenSeaUser | null
// }

// export interface PaymentTokenToken extends Token {
//     imageUrl?: string
//     ethPrice?: string
//     usdPrice?: string
// }

/**
 * Orders don't need to be signed if they're pre-approved
 * with a transaction on the contract to approveOrder_
 */
// export interface Order extends UnsignedOrder, Partial<ECSignature> {
//     // Read-only server-side appends
//     createdTime?: BigNumber
//     currentPrice?: BigNumber
//     currentBounty?: BigNumber
//     makerAccount?: OpenSeaAccount
//     takerAccount?: OpenSeaAccount
//     feeRecipientAccount?: OpenSeaAccount
//     paymentTokenContract?: PaymentTokenToken
//     cancelledOrFinalized?: boolean
//     markedInvalid?: boolean
//     asset?: any
//     assetBundle?: any
//     id?: any
//     orderHash?: any
// }


/******************** Fees ***********************/
/**
 * The basis point values of each type of fee
 */
export interface OpenSeaFees {
    // Fee for Element levied on sellers
    elementSellerFeeBasisPoints: number
    // Fee for Element levied on buyers
    elementBuyerFeeBasisPoints: number
    // Fee for the collection owner levied on sellers
    devSellerFeeBasisPoints: number
    // Fee for the collection owner levied on buyers
    devBuyerFeeBasisPoints: number
}

/**
 * Fully computed fees including bounties and transfer fees
 */
export interface ComputedFees extends OpenSeaFees {
    // Total fees. dev + element
    totalBuyerFeeBasisPoints: number
    totalSellerFeeBasisPoints: number

    // Fees that the item's creator takes on every transfer
    transferFee: BigNumber
    transferFeeTokenAddress: string | null

    // Fees that go to whoever refers the order to the taker.
    // Comes out of OpenSea fees
    sellerBountyBasisPoints: number
}




//----------- OrderJSON--------------
export interface ECSignature {
    v: number
    r: string
    s: string
}

export interface OrderJSON extends Partial<ECSignature> {
    exchange: string
    maker: string
    taker: string
    makerRelayerFee: string
    takerRelayerFee: string
    makerProtocolFee: string
    takerProtocolFee: string
    makerReferrerFee: string
    feeRecipient: string
    feeMethod: number
    side: number
    saleKind: number
    target: string
    howToCall: number
    calldata: string
    replacementPattern: string
    staticTarget: string
    staticExtradata: string
    paymentToken: string
    quantity: string
    basePrice: string
    englishAuctionReservePrice: string | undefined
    extra: string

    // createdTime is undefined when order hasn't been posted yet
    // createdTime?: number | string
    listingTime: number | string
    expirationTime: number | string

    salt: string

    metadata: ExchangeMetadata

    hash: string
    nonce?: number | string
    orderHash?: string
    chain?: string
    chainId?: string
}

